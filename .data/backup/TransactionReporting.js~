/**
 * @file TransactionReporting.js
 * @copyright (C) United Airlines Inc. 2017
 * @author Sampath Singamsetty <Sampath.Singamsetty@united.com>
 * @version 1.0
 * @date 09-19-2017
 *
 * @description Gatewayscript for taking a transaction snapshot for logging.
 * <br>
 *
 * As a part of the Datapower  OpenID Connect Framework, this particular gatewayscript
 * when placed at the end of the transaction processing on the rule as parallel action
 * will take a snapshot of the previous request/response based on its content type and
 * will prepare a customized  report for the log target.  A separate transformation on
 * the logger rule can  be used to prune any  unwanted elements and prepare a properly
 * formwatted log message.
 *
 *
 * @module TransactionReporting
 */


/**
 * datapower service variable for fine grained metadata and
 * service specific information
 * @var {object} sm
 */
var sm = require('service-metadata');

/**
 * datapower service variable for header metadata
 * @var {object} hm
 */
var hm = require('header-metadata');

/**
 * datapower service variable for loading and running xslt transformations
 * @var {object} transform
 */
var transform = require('transform');

/**
 * a variable for getting hold of the respective http protocol
 * method used for invoking the call like GET/PUT/POST/OPTIONS etc.
 * @var {string} protocolMethod
 */
var protocolMethod = sm.getVar('var://service/protocol-method');

/**
 * a variable for getting hold of the incoming service uri
 * @var {string} uri
 */
var uri = sm.getVar('var://service/URI');

/**
 * a variable for getting hold of the outbound service call details
 * @var {string} urlout
 */
var urlout = sm.getVar('var://service/URL-out');

/**
 * a free variable for getting hold of any AAA related errors if othey occur
 * @var {string} aaaErrorDescription
 */
var aaaErrorDescription;/**

/**
 * A variable for helping with the xpath expression run over the xml formatted
 * AAA message output description. It holds the required options and the xpath
 * @var {object} options
 */
var options = {
  'expression': '//description',
  'xmldom': XML.parse(sm.getVar("var://service/aaa-error-logs"))
};

transform.xpath(options, function(err, xmlNodeList) {
  if (err) {
    console.error('******** error ' + err + ' ********');
  } else {
    aaaErrorDescription = XML.stringify({
      omitXmlDeclaration: true
    }, xmlNodeList);
  }
});

/**
 * A variable for holding the options required for parsing xml data
 * @var {object} xmlOptions
 */
var xmlOption = {
  omitXmlDeclaration: true
};

/**
 * A variable for holding all the header metdata stack of the request/response
 * @var {object} headers
 */
var headers = hm.current.headers;

/**
 * A free variable for parsing and holding the headers
 * @var {object} arr
 */
var arr = [];

/**
 * A free variable for parsing and holding the individual header information
 * @var {object} obj
 */
var obj = {};

for (var h in headers) {
  obj[h] = headers[h];
  arr.push(obj);
  obj = {};
}

/**
 * A free variable for holding the datapower device name
 * @var {string} device
 */
var device;

/**
 * A free variable for holding the datapower firmware
 * @var {object} firmware
 */
var firmware;

/**
 * A variable for holding the options required to run an xpath expression
 * over the xml formatted datapower system identity node set
 * @var {object} deviceOptions
 */
var deviceOptions = {
  'expression': '//device-name',
  'xmldom': XML.parse(sm.getVar("var://service/system/ident"))
};

transform.xpath(deviceOptions, function(err, xmlNodeList) {
  if (err) {
    console.error('******** error ' + err + ' ********');
  } else {
    device = XML.stringify({
      omitXmlDeclaration: true
    }, xmlNodeList);
  }
});

/**
 * A variable for holding the raw datapower firmware information which
 * needs to be parsed to get the string output.
 * @var {object} fwOptions
 */
var fwOptions = {
  'expression': '//firmware-version',
  'xmldom': XML.parse(sm.getVar("var://service/system/ident"))
};

transform.xpath(fwOptions, function(err, xmlNodeList) {
  if (err) {
    console.error('******** error ' + err + ' ********');
  } else {
    firmware = XML.stringify({
      omitXmlDeclaration: true
    }, xmlNodeList);
  }
});

/**
 * A variable for holding the success state of the transaction in textual format
 * @var {string} success
 */
var success = 'SUCCESS';

/**
 * A variable for holding the failure state of the transaction in textual format
 * @var {string} failure
 */
var failure = 'FAILURE';

/**
 * A variable for holding the datapower device generated error codes if any
 * @var {string} errorCode
 */
var errorCode = sm.getVar('var://service/error-code');

/**
 * A variable for holding the datapower device generated error sub codes if any
 * @var {string} errorSubCode
 */
var errorSubCode = sm.getVar('var://service/error-subcode');

/**
 * A variable for holding the datapower device generated error messages if any
 * @var {string} errorMsg
 */
var errorMsg = sm.getVar('var://service/error-message');

/**
 * A variable for holding the actual client address information for auditing
 * @var {string} clientIp
 */
var clientIp = sm.getVar('var://service/transaction-client');

/**
 * A variable for holding the root contextual information if available
 * @var {object} oauth
 */
var oauth = session.name('oauth') ? session.name('oauth') : '';

/**
 * A variable for holding the oauth client identifier information for auditing
 * @var {string} clientId
 */
var clientId = typeof oauth !== "undefined" ? oauth.getVariable('client_id') : '';

/**
 * A variable for holding the oauth client resource username information for auditing
 * if available from the request or AAA metadata
 * @var {string} username
 */
var username = typeof oauth !== "undefined" ? oauth.getVariable("username") : '';

/**
 * A variable for holding the CSS service related error information for auditing
 * @var {string} cssError
 */
var cssError = typeof oauth !== "undefined" ? oauth.getVariable('css-error') : '';

/**
 * A variable for holding the JWT token jti information for auditing
 * @var {string} jti
 */
var jti = typeof oauth !== "undefined" ? oauth.getVariable('jwt_jti_value') : '';

/**
 * A free variable acting as a helper for holding the xml node lists
 * @var {string} nodeList
 */
var nodeList;

/**
 * @function isEmpty
 * Check if a given string is empty or not
 * @param {string} str - The input string for checking
 * @returns {boolean} Returns true or false based on whether the
 *                    string is empty or not.
 */
function isEmpty(str) {
  if (typeof str === 'undefined' ||
    !str ||
    str.length === 0 ||
    str === "" ||
    !/[^\s]/.test(str) ||
    /^\s*$/.test(str) ||
    str.replace(/\s/g, "") === "") {
    return true;
  } else {
    return false;
  }
}

/**
 * Function for stripping off the xml tags from a string equivalent of
 * an xml element nodeset. Rather than parsing a single xml nodeset in
 * the form of a string using the  DOM, this function  just strips off
 * the tags and returns only the value.
 * @param {string} str - this would be the string form of xml nodeset
 * @param {string} tag - the tags to be removed from the nodeset
 * @returns {object} return the object value from nodeset
 */
function removeTags(str, tag) {
  var pretag = '<' + tag + '>';
  var posttag = '</' + tag + '>';
  return str.split(pretag)[1].split(posttag)[0];
}

/**
 * Function to return the appropriate xml string with return code.
 * The function after taking values of interset creates an xml node
 * which can be inserted into the datapower log snippet.
 * @param {string} dperr - datapower error code
 * @param {string} csserr - css error string message if any
 * @param {string} aaaerr - aaa error if any available
 * @param {string} errmsg - datapower error message from service variables
 * @param {string} succ - a string SUCCESS to return for valid transactions
 * @param {string} fail - a string FAILURE to return for invalid transactions
 * @returns {string} returns an string equivalent of an xml nodeset
 */
function getReturnCode(dphexcode, csserr, aaaerr, errmsg, succ, fail) {
  if (dphexcode === '0x00000000' && isEmpty(csserr)) {
    console.debug('Datapower Error Code ' + dphexcode);
    var succnode = '     <retcode>' + succ + '</retcode>';
    return succnode;
  } else {
    console.debug('dperrcode ' + dphexcode);
    console.debug('errmsg ' + errmsg);
    console.debug('aaaerr ' + aaaerr);
    console.debug('csserr ' + csserr);
    var dpAAAError = removeTags(aaaerr, "description");
    var errorMessage = isEmpty(csserr) ? dpAAAError : dpAAAError + ' css error ' + csserr;
    console.debug('ERROR MESSAGE ' + errorMessage);
    var failnode = '    <retcode>' + fail + '</retcode>\n' +
      '    <dperrcode>' + dphexcode + '</dperrcode>\n' +
      '    <dperrmsg>' + errmsg + '</dperrmsg>\n' +
      '    <exception>' + errorMessage + '</exception>\n';
    return failnode;
  }
}

/**
 * A free variable serving as a helper for holding the service return code values
 * @var {string} returnCode
 */
var returnCode;

/**
 * A variable for holding the service request/response content-type information
 * @var {string} contentType
 */
var contentType = sm.getVar('var://service/original-content-type');

/**
 * A variable for holding the actual transaction time in milli seconds from the
 * datapower(s) real time clock.
 * @var {number} transactionTime
 */
var transactionTime = sm.getVar('var://service/time-elapsed');

/**
 * A variable for holding the actual error code generated by datapower out of both
 * the main error code and error sub code. If subcode is not 0x00000000 then it will
 * be picked other wise the main error code is picked.
 * @var {string} dpErrorCode
 */
var dpErrorCode = errorSubCode === '0x00000000' ? errorCode : errorSubCode;


session.input.readAsJSON(function(jsonError, data) {
  if (jsonError) {
    session.input.readAsBuffers(function(bufferError, data) {
      if (bufferError) {
        session.output.write(XML.parse('<error>' + bufferError + '</error>'));
      } else {
        if (contentType.indexOf('xml') > -1) {
          var subList = '    <uri>' + uri + '</uri>\n' +
            '    <destinationUrl>' + urlout + '</destinationUrl>\n' +
            '    <client-id>' + clientId + '</client-id>\n' +
            '    <username>' + username + '</username>\n' +
            '    <source>' + clientIp + '</source>\n' +
            '    <jti>' + jti + '</jti>\n' +
            '    <transaction-time>' + transactionTime + '</transaction-time>\n' +
            '    <httpMethod>' + protocolMethod + '</httpMethod>\n' +
            '    <device>' + device + '</device>\n' +
            '    <firmware>' + firmware + '</firmware>';

          returnCode = getReturnCode(dpErrorCode, cssError, aaaErrorDescription, errorMsg, success, failure);

          nodeList = '<DPStatistics>\n' +
            subList + '\n' +
            returnCode + '\n' +
            '</DPStatistics>';
          session.output.write(XML.parse(nodeList));
        } else {
          var subList = '    <uri>' + uri + '</uri>\n' +
            '    <destinationUrl>' + urlout + '</destinationUrl>\n' +
            '    <client-id>' + clientId + '</client-id>\n' +
            '    <username>' + username + '</username>\n' +
            '    <source>' + clientIp + '</source>\n' +
            '    <jti>' + jti + '</jti>\n' +
            '    <transaction-time>' + transactionTime + '</transaction-time>\n' +
            '    <httpMethod>' + protocolMethod + '</httpMethod>\n' +
            '    <device>' + device + '</device>\n' +
            '    <firmware>' + firmware + '</firmware>';

          returnCode = getReturnCode(dpErrorCode, cssError, aaaErrorDescription, errorMsg, success, failure);

          nodeList = '<DPStatistics>\n' +
            subList + '\n' +
            returnCode + '\n' +
            '</DPStatistics>';
          session.output.write(XML.parse(nodeList));
        }
      }
    });
  } else {
    var subList = '    <uri>' + uri + '</uri>\n' +
      '    <destinationUrl>' + urlout + '</destinationUrl>\n' +
      '    <client-id>' + clientId + '</client-id>\n' +
      '    <username>' + username + '</username>\n' +
      '    <source>' + clientIp + '</source>\n' +
      '    <jti>' + jti + '</jti>\n' +
      '    <transaction-time>' + transactionTime + '</transaction-time>\n' +
      '    <httpMethod>' + protocolMethod + '</httpMethod>\n' +
      '     ' + device + '\n' +
      '     ' + firmware;

    returnCode = getReturnCode(dpErrorCode, cssError, aaaErrorDescription, errorMsg, success, failure);

    nodeList = '<DPStatistics>\n' +
      subList + '\n' +
      returnCode + '\n' +
      '</DPStatistics>';
    session.output.write(XML.parse(nodeList));
  }
});
